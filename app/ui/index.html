<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>SDLC AI</title>

  <style>
    body {
      font-family: Arial;
      margin: 40px;
      max-width: 900px;
    }

    textarea#idea {
      width: 100%;
      height: 80px;
    }

    .step {
      margin: 10px 0;
      padding: 10px;
      border-radius: 6px;
    }

    .pending {
      background: #eee;
    }

    .running {
      background: #fff3cd;
    }

    .completed {
      background: #d4edda;
    }

    .header {
      display: flex;
      justify-content: space-between;
      cursor: pointer;
      font-weight: bold;
    }

    .body {
      display: none;
      margin-top: 10px;
      background: #111;
      color: #ddd;
      padding: 14px;
      border-radius: 4px;
    }

    .section {
      margin-top: 14px;
    }

    .section-title {
      color: #9cdcfe;
      font-weight: bold;
      margin-bottom: 6px;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin-bottom: 4px;
    }

    .meta {
      color: #8bc34a;
      font-size: 13px;
    }
  </style>
</head>

<body>

  <h2>SDLC AI</h2>

  <textarea id="idea">Mobile app for financial investments</textarea><br><br>
  <button onclick="startJob()">Start Job</button>

  <h3>Status</h3>
  <div id="status">Idle</div>

  <h3>Workflow</h3>
  <div id="steps"></div>

  <script>
    const API = "/api/workflows";
    let jobId = null;
    let poller = null;

    const created = {};
    const expanded = {};
    const cache = {};

    const LABELS = {
      intake: "Problem Statement",
      scope: "Scope Definition",
      requirements: "Requirements Breakdown",
      architecture: "Architecture Design",
      estimation: "Effort Estimation",
      risk: "Risk Analysis",
      sow: "Statement of Work"
    };

    /* ---------------- START ---------------- */

    function startJob() {
      fetch(`${API}/start`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ product_idea: idea.value })
      })
        .then(r => r.json())
        .then(d => {
          jobId = d.job_id;
          status.innerText = `Job started (${jobId})`;
          fetchStatus();
          poller = setInterval(fetchStatus, 3000);
        });
    }

    /* ---------------- STATUS ---------------- */

    function fetchStatus() {
      fetch(`${API}/${jobId}/status`)
        .then(r => r.json())
        .then(updateUI);
    }

    function updateUI(data) {
      status.innerText =
        data.current_step === "completed"
          ? "Workflow completed ✅"
          : "Current step: " + LABELS[data.current_step];

      for (const step in data.steps) {
        if (!created[step]) createStep(step);
        updateStep(step, data.steps[step]);
      }

      if (data.current_step === "completed" && poller) {
        clearInterval(poller);
        poller = null;
      }
    }

    /* ---------------- STEP UI ---------------- */

    function createStep(step) {
      const container = document.getElementById("steps");

      const box = document.createElement("div");
      box.id = `step-${step}`;
      box.className = "step pending";

      const header = document.createElement("div");
      header.className = "header";
      header.innerHTML = `<span>${LABELS[step]}</span><span id="state-${step}"></span>`;

      const body = document.createElement("div");
      body.id = `body-${step}`;
      body.className = "body";

      header.onclick = () => {
        expanded[step] = !expanded[step];
        body.style.display = expanded[step] ? "block" : "none";
        if (expanded[step] && !cache[step]) fetchStep(step);
      };

      box.appendChild(header);
      box.appendChild(body);
      container.appendChild(box);
      created[step] = true;
    }

    /* ---------------- STEP STATE ---------------- */

    function updateStep(step, state) {
      document.getElementById(`step-${step}`).className = `step ${state}`;
      document.getElementById(`state-${step}`).innerText = state;
    }

    /* ---------------- STEP DATA ---------------- */

    function fetchStep(step) {
      fetch(`${API}/${jobId}/steps/${step}`)
        .then(r => r.json())
        .then(res => {
          cache[step] = res;
          renderStep(step);
        });
    }

    function renderStep(step) {
  const body = document.getElementById(`body-${step}`);
  const raw = cache[step]?.data?.output?.raw_output;

  if (!raw) {
    body.innerHTML = "<div class='section'>No output</div>";
    return;
  }

  const meta = `
    <div class="meta">
      Status: ${cache[step].data.status}<br>
      Started: ${cache[step].data.started_at}<br>
      Completed: ${cache[step].data.completed_at}
    </div>
  `;

  // Intake: structured human rendering
  if (step === "intake") {
    body.innerHTML = meta + renderHumanReadable(raw);
    return;
  }

  // Normalize text
  const cleaned = stripMarkdownFences(raw);

  // Try JSON (non-fatal)
  const prettyJson = safePrettyJson(cleaned);

  // Always render via textContent-equivalent
  const content = prettyJson ?? cleaned;

  body.innerHTML = `
    ${meta}
    <div class="section">
      <pre style="white-space: pre-wrap;">${escapeHtml(content)}</pre>
    </div>
  `;
}




    /* ---------------- HUMAN OUTPUT ---------------- */
    function cleanText(text) {
      return text
        .replace(/```[\s\S]*?```/g, "")          // remove code fences
        .replace(/Status:.*?\n/gi, "")
        .replace(/Started:.*?\n/gi, "")
        .replace(/Completed:.*?\n/gi, "")
        .replace(/[{}\[\]"]/g, "")               // remove JSON symbols
        .replace(/\\n/g, "\n")
        .replace(/\s+/g, " ")
        .trim();
    }

    function extractSection(source, startKey, endKeys = []) {
      const endPattern = endKeys.length
        ? endKeys.join("|")
        : "$";

      const regex = new RegExp(
        startKey + "\\s*(.*?)(?=" + endPattern + "|$)",
        "i"
      );

      const match = source.match(regex);
      return match ? match[1].trim() : "";
    }

    function toBullets(text) {
      return text
        .split(/[,•\n]/)
        .map(t => t.trim())
        .filter(t => t.length > 3)
        .map(t => `<li>${t}</li>`)
        .join("");
    }

    function renderHumanReadable(rawText) {
      const text = cleanText(rawText);

      const problem = extractSection(
        text,
        "problem",
        ["causes", "effects", "target audience"]
      );

      const causes = extractSection(
        text,
        "causes",
        ["effects", "target audience"]
      );

      const effects = extractSection(
        text,
        "effects",
        ["target audience"]
      );

      const target = extractSection(
        text,
        "target audience"
      );

      return `
    ${problem ? `
      <div class="section">
        <div class="section-title">Problem</div>
        <div>${problem}</div>
      </div>` : ""}

    ${causes ? `
      <div class="section">
        <div class="section-title">Causes</div>
        <ul>${toBullets(causes)}</ul>
      </div>` : ""}

    ${effects ? `
      <div class="section">
        <div class="section-title">Effects</div>
        <ul>${toBullets(effects)}</ul>
      </div>` : ""}

    ${target ? `
      <div class="section">
        <div class="section-title">Target Audience</div>
        <div>${target}</div>
      </div>` : ""}
  `;
    }

    function extractJsonFromText(text) {
      // Remove ```json ... ``` or ``` ... ```
      const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
      if (fenced) {
        return fenced[1].trim();
      }
      return null;
    }

    function prettyPrintJson(jsonText) {
      try {
        const obj = JSON.parse(jsonText);
        return JSON.stringify(obj, null, 2);
      } catch {
        return null;
      }
    }

    function stripMarkdownFences(text) {
      return text
        .replace(/```json/gi, "")
        .replace(/```/g, "")
        .trim();
    }

    function safePrettyJson(text) {
      try {
        const obj = JSON.parse(text);
        return JSON.stringify(obj, null, 2);
      } catch {
        return null;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.innerText = text;
      return div.innerHTML;
    }

  </script>

</body>

</html>