<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>SDLC AI</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      max-width: 900px;
    }

    textarea {
      width: 100%;
      height: 80px;
      padding: 8px;
      font-size: 14px;
    }

    button {
      padding: 6px 12px;
      cursor: pointer;
      margin-left: 6px;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .step {
      padding: 10px;
      margin: 8px 0;
      border-radius: 6px;
      font-size: 14px;
    }

    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .pending { background: #eee; }
    .running { background: #fff3cd; }
    .completed { background: #d4edda; }
    .failed { background: #f8d7da; }

    .meta {
      font-size: 12px;
      opacity: 0.8;
    }

    .error {
      color: #b00020;
      font-weight: bold;
    }

    pre {
      background: #111;
      color: #0f0;
      padding: 10px;
      margin-top: 8px;
      display: none;
      font-size: 12px;
      overflow-x: auto;
    }

    h3 {
      margin-top: 30px;
    }
  </style>
</head>

<body>

<h1>SDLC AI</h1>

<h3>Product Idea</h3>
<textarea id="idea" placeholder="Describe your product idea..."></textarea>
<br />
<button onclick="startJob()">Start Job</button>

<h3>Status</h3>
<div id="status">Idle</div>

<h3>Workflow Progress</h3>
<div id="steps"></div>

<script>
/* ================= GLOBAL STATE ================= */

let jobId = null;
let poller = null;
let evtSource = null;

/* ✅ FIX: cache to prevent repeated step fetches */
const stepOutputCache = {};

const API = "/api/workflows";

const STEP_LABELS = {
  intake: "Problem Statement",
  scope: "Scope Definition",
  requirements: "Requirements Breakdown",
  architecture: "Architecture Design",
  estimation: "Effort Estimation",
  risk: "Risk Analysis",
  sow: "Statement of Work"
};

/* ================= JOB CONTROL ================= */

function startJob() {
  const idea = document.getElementById("idea").value.trim();
  if (!idea) {
    alert("Please enter a product idea");
    return;
  }

  fetch(`${API}/start`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ product_idea: idea })
  })
    .then(r => r.json())
    .then(data => {
      jobId = data.job_id;
      document.getElementById("status").innerText =
        `Job started (ID: ${jobId})`;

      /* reset state for new job */
      Object.keys(stepOutputCache).forEach(k => delete stepOutputCache[k]);

      startPolling();
      attachSSE();
    })
    .catch(console.error);
}

function startPolling() {
  if (poller) clearInterval(poller);
  poller = setInterval(fetchStatus, 3000);
}

function fetchStatus() {
  if (!jobId) return;

  fetch(`${API}/${jobId}/status`)
    .then(r => r.json())
    .then(renderStatus)
    .catch(console.error);
}

/* ================= RENDERING ================= */

function renderStatus(data) {
  const stepsDiv = document.getElementById("steps");
  stepsDiv.innerHTML = "";

  document.getElementById("status").innerText =
    `Current step: ${STEP_LABELS[data.current_step] ?? data.current_step}`;

  if (data.dead_letter) {
    document.getElementById("status").innerHTML =
      `<span class="error">❌ Job dead-lettered at ${STEP_LABELS[data.dead_letter.step]}</span>`;
    clearInterval(poller);
  }

  for (const [step, state] of Object.entries(data.steps)) {
    const retries = data.retries?.[step] ?? 0;
    const error = data.errors?.[step];

    const div = document.createElement("div");
    div.className = `step ${state}`;

    const header = document.createElement("div");
    header.className = "step-header";
    header.innerHTML = `
      <strong>${STEP_LABELS[step]}</strong>
      <span class="meta">
        ${state} | retries: ${retries}
      </span>
    `;

    const pre = document.createElement("pre");
    pre.id = `output-${step}`;

    header.onclick = () => {
      pre.style.display = pre.style.display === "block" ? "none" : "block";
    };

    div.appendChild(header);
    div.appendChild(pre);
    stepsDiv.appendChild(div);

    /* ✅ fetch output ONCE per completed step */
    if (state === "completed") {
      fetchStepResult(step);
    }

    if (state === "failed" && error) {
      pre.style.display = "block";
      pre.textContent = JSON.stringify(error, null, 2);
    }
  }
}

/* ================= STEP OUTPUT ================= */

function fetchStepResult(step) {
  if (stepOutputCache[step]) return; // ✅ FIX: stop repeated calls

  fetch(`${API}/${jobId}/steps/${step}`)
    .then(r => {
      if (!r.ok) throw new Error("Step not found");
      return r.json();
    })
    .then(data => {
      stepOutputCache[step] = data;

      const pre = document.getElementById(`output-${step}`);
      if (!pre) return;

      pre.textContent = JSON.stringify(data.data ?? data, null, 2);
    })
    .catch(console.error);
}

/* ================= SSE ================= */

function attachSSE() {
  if (evtSource) evtSource.close();

  evtSource = new EventSource(`${API}/events/${jobId}`);

  evtSource.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (
      msg.event === "step_completed" ||
      msg.event === "step_failed" ||
      msg.event === "job_dead_lettered"
    ) {
      fetchStatus();
    }
  };
}
</script>

</body>
</html>
