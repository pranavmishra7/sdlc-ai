<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>SDLC AI</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      max-width: 900px;
    }

    textarea {
      width: 100%;
      height: 80px;
      padding: 8px;
      font-size: 14px;
    }

    button {
      padding: 6px 12px;
      cursor: pointer;
      margin-left: 6px;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .step {
      padding: 10px;
      margin: 8px 0;
      border-radius: 6px;
      font-size: 14px;
    }

    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .pending { background: #eee; }
    .running { background: #fff3cd; }
    .completed { background: #d4edda; }
    .failed { background: #f8d7da; }

    .meta {
      font-size: 12px;
      opacity: 0.8;
    }

    .error {
      color: #b00020;
      font-weight: bold;
    }

    pre {
      background: #111;
      color: #0f0;
      padding: 10px;
      margin-top: 8px;
      display: none;
      font-size: 12px;
      overflow-x: auto;
    }

    h3 {
      margin-top: 30px;
    }
  </style>
</head>

<body>

<h1>SDLC AI</h1>

<h3>Product Idea</h3>
<textarea id="idea" placeholder="Describe your product idea..."></textarea>
<br />
<button onclick="startJob()">Start Job</button>

<h3>Status</h3>
<div id="status">Idle</div>

<h3>Workflow Progress</h3>
<div id="steps"></div>

<script>
let jobId = null;
let poller = null;
let evtSource = null;

const API = "/api/workflows";

const STEP_LABELS = {
  intake: "Problem Statement",
  scope: "Scope Definition",
  requirements: "Requirements Breakdown",
  architecture: "Architecture Design",
  estimation: "Effort Estimation",
  risk: "Risk Analysis",
  sow: "Statement of Work"
};

function startJob() {
  const idea = document.getElementById("idea").value;

  fetch(`${API}/start`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ product_idea: idea })
  })
    .then(r => r.json())
    .then(data => {
      jobId = data.job_id;
      document.getElementById("status").innerText =
        `Job started (ID: ${jobId})`;
      startPolling();
      attachSSE();
    });
}

function startPolling() {
  if (poller) clearInterval(poller);
  poller = setInterval(fetchStatus, 3000);
}

function fetchStatus() {
  if (!jobId) return;

  fetch(`${API}/${jobId}/status`)
    .then(r => r.json())
    .then(renderStatus);
}

function renderStatus(data) {
  const stepsDiv = document.getElementById("steps");
  stepsDiv.innerHTML = "";

  /* -------- total workflow timing -------- */
  if (data.started_at) {
    const start = new Date(data.started_at);
    const end = data.completed_at ? new Date(data.completed_at) : new Date();
    const totalSec = Math.round((end - start) / 1000);

    document.getElementById("status").innerText =
      `Current step: ${STEP_LABELS[data.current_step] ?? data.current_step}
       | Total time: ${totalSec}s`;
  }

  if (data.dead_letter) {
    document.getElementById("status").innerHTML =
      `<span class="error">❌ Job dead-lettered at ${STEP_LABELS[data.dead_letter.step]}</span>`;
    clearInterval(poller);
  }

  for (const [step, state] of Object.entries(data.steps)) {
    const retries = data.retries?.[step] ?? 0;
    const maxRetries = data.retry_policy?.[step] ?? "—";
    const error = data.errors?.[step];
    const meta = data.steps_meta?.[step] ?? {};

    /* -------- step duration -------- */
    let duration = "—";
    if (meta.duration_sec !== undefined) {
      duration = `${meta.duration_sec}s`;
    } else if (meta.started_at) {
      const end = meta.completed_at
        ? new Date(meta.completed_at)
        : new Date();
      duration = `${Math.round((end - new Date(meta.started_at)) / 1000)}s`;
    }

    const div = document.createElement("div");
    div.className = `step ${state}`;

    const header = document.createElement("div");
    header.className = "step-header";
    header.innerHTML = `
      <strong>${STEP_LABELS[step]}</strong>
      <span class="meta">
        ${state}
        | time: ${duration}
        | retries: ${retries}/${maxRetries}
        ${state === "failed" ? `<button onclick="retryJob()">Retry</button>` : ""}
      </span>
    `;

    const pre = document.createElement("pre");
    pre.id = `output-${step}`;

    header.onclick = () => {
      pre.style.display = pre.style.display === "none" ? "block" : "none";
    };

    div.appendChild(header);
    div.appendChild(pre);
    stepsDiv.appendChild(div);

    if (state === "completed") {
      fetchStepResult(step);
    }

    if (state === "failed" && error) {
      pre.style.display = "block";
      pre.textContent = JSON.stringify(error, null, 2);
    }
  }
}

function fetchStepResult(step) {
  fetch(`${API}/${jobId}/steps/${step}`)
    .then(r => {
      if (!r.ok) throw new Error("Step not found");
      return r.json();
    })
    .then(data => {
      const pre = document.getElementById(`output-${step}`);
      if (!pre) return;

      pre.style.display = "block";
      pre.textContent = JSON.stringify(data.data ?? data, null, 2);
    })
    .catch(err => {
      console.error(err);
    });
}

function attachSSE() {
  if (evtSource) evtSource.close();

  evtSource = new EventSource(`${API}/events/${jobId}`);

  evtSource.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (
      msg.event === "step_completed" ||
      msg.event === "step_failed" ||
      msg.event === "step_auto_retry" ||
      msg.event === "job_dead_lettered"
    ) {
      fetchStatus();
    }
  };
}

function retryJob() {
  if (!jobId) return;

  fetch(`${API}/${jobId}/retry`, { method: "POST" })
    .then(() => {
      document.getElementById("status").innerText = "Retry triggered…";
      startPolling();
    });
}
</script>

</body>
</html>
